<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
        color: #fff;
			}
      #download_link {
        position: absolute;
        bottom: 0px;
      }
      #holder {
        position: absolute;
        top: 50%;
        border: 5px dashed #ccc;
        width: 1000px;
        height: 500px;
        margin: auto;
        left: 50%;
        margin-left: -500px;
        margin-top: -250px;
      }
      #holder.hover {
        border: 5px dashed #333;
        background-color: rgba(255,255,255,.2);
      }

		</style>
	</head>
	<body>

		<script src="/three.js"></script>
    <script src="/loaders/STLLoader.js"></script>
    <script src="/loaders/OBJLoader.js"></script>
    <script src="/loaders/BufferGeometryLoader.js"></script>
    <script src="/wip/TypedGeometry.js"></script>
    <script src="/wip/BufferGeometryUtils.js"></script>
    <script src="/exporters/BufferGeometryExporter.js"></script>
    <script src="/exporters/TypedGeometryExporter.js"></script>

		<script>
      window.onload = function() {

        // setup file drop area
        var holder = document.getElementById('holder');
        holder.ondragover = function () { this.className = 'hover'; return false; };
        holder.ondragend = function () { this.className = ''; return false; };
        holder.ondrop = function (e) {
          this.className = '';
          e.preventDefault();

          var file = e.dataTransfer.files[0];
          var reader = new FileReader();
          reader.onload = function (event) {
            console.log(event.target.result);
            var download_element = document.getElementById('download_link');
            // FIXME the normal way of elementing didn't work?
//            var download_link = document.createElement('a');
//            download_link.innerHTML = "download original";
//            download_link.setAttribute("href", "data:"+event.target.result);
//            download_link.setAttribute("download", "data.file");
//            download_element.appendChild(download_link);
//            download_element.innerHTML += ' <a href="data:' + event.target.result + '" download="data.file">download original</a>';

            if ( file.type.match("^image") )
            {

              if ( scene.children.length )
              {
                var texture = THREE.ImageUtils.loadTexture( event.target.result );
                texture.anisotropy = renderer.getMaxAnisotropy();
                var material = new THREE.MeshBasicMaterial( { map: texture } );
                var object = scene.children[scene.children.length-1];
                for ( var i=0; i<object.children.length; i++ )
                  object.children[i].material = material;
              }
              else
              {
                holder.style.background = 'url(' + event.target.result + ') no-repeat center';
              }
            }
            if ( file.name.match(/\.stl$/) )
            {
              // TODO none of the STL stuff works
              var loader = new THREE.STLLoader();

              var geometry = loader.parse( event.target.result );
              var texture = THREE.ImageUtils.loadTexture( 'textures/test.png' );
              texture.anisotropy = renderer.getMaxAnisotropy();
              var material = new THREE.MeshBasicMaterial( { map: texture } );

              var mesh = new THREE.Mesh( geometry, material );

              mesh.position.set( 0, - 0.25, 0.6 );
              mesh.rotation.set( 0, - Math.PI / 2, 0 );
              mesh.scale.set( 50, 50, 50 );

              mesh.castShadow = true;
              mesh.receiveShadow = true;

              scene.add( mesh );
              loadedModel = mesh;

              var exporter = new THREE.TypedGeometryExporter();

              var download_element = document.getElementById('download_link');
              var data = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exporter.parse(geometry)));
              download_element.innerHTML += '<a href="data:' + data + '" download="data.js">download JSON</a>';
            }
            if ( file.name.match(/\.obj$/) )
            {
              // load something
              var loader = new THREE.OBJLoader();

              var object = loader.parse( event.target.result );
              var texture = THREE.ImageUtils.loadTexture( 'textures/test.png' );
              texture.anisotropy = renderer.getMaxAnisotropy();
              var material = new THREE.MeshBasicMaterial( { map: texture } );

              for ( var i=0; i<object.children.length; i++ )
              {
                object.children[i].material = material;
                object.children[i].geometry = THREE.BufferGeometryUtils.fromGeometry( object.children[i].geometry );
              }
              scene.add( object );

              var exporter = new THREE.BufferGeometryExporter();

              var download_element = document.getElementById('download_link');
              var data = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exporter.parse(THREE.BufferGeometryUtils.fromGeometry( object.children[0].geometry) )));
              download_element.innerHTML += ' <a href="data:' + data + '" download="data.js">download JSON</a>';
            }
            if ( file.name.match(/\.js$/) )
            {
              // initialize our geometry
              var geometry = new THREE.BufferGeometry();
              var input = JSON.parse( event.target.result );

              // we need a way of creating an array of the proper type,
              // defining those types here
              var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
              for ( var attr in input.attributes )
              {
                // copy over an attribute
                var sourceAttr = input.attributes[ attr ];
                var sourceArray = sourceAttr.array;
                var attribute = {
                  itemSize: sourceAttr.itemSize,
                  numItems: sourceAttr.numItems,
                  array: null
                };
                // detect our type
                var type = sourceAttr.type;
                function functionName(fun) {
                  var ret = fun.toString();
                  ret = ret.substr('function '.length);
                  ret = ret.substr(0, ret.indexOf('('));
                  return ret;
                }
                for ( var i = 0, il = types.length; i < il; i ++ ) {
                  var type = types[ i ];
                  if ( sourceAttr.type == functionName(type) ) {
                    attribute.array = new type( sourceArray );
                    break;
                  }
                }
                // add this attribute
                geometry.attributes[ attr ] = attribute;
              }

              var texture = THREE.ImageUtils.loadTexture( 'textures/test.png' );
              texture.anisotropy = renderer.getMaxAnisotropy();
              var material = new THREE.MeshBasicMaterial( { map: texture } );
              var mesh = new THREE.Mesh( geometry, material );

              scene.add( mesh );
            }

          }

          if ( file.type.match("^image") )
            reader.readAsDataURL(file);
          else
            reader.readAsText(file);

          return false;
        };
      };

			var camera, scene, renderer;
			var mesh;
      var loadedModel;

			init();
			animate();

			function init() {
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 20;

				scene = new THREE.Scene();

        // test box
        if ( false )
        {
          var geometry = new THREE.BoxGeometry( 2, 2, 2 );
          var texture = THREE.ImageUtils.loadTexture( 'textures/test.png' );
          texture.anisotropy = renderer.getMaxAnisotropy();
          var material = new THREE.MeshBasicMaterial( { map: texture } );
          mesh = new THREE.Mesh( geometry, material );
          scene.add( mesh );
        }
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );

        for ( var i=0; i<scene.children.length; i++ )
        {
          scene.children[i].rotation.x += 0.005;
          scene.children[i].rotation.y += 0.01;
          scene.children[i].rotation.z += 0.001*(i);
        }

				renderer.render( scene, camera );
			}

		</script>

    <div id="download_link"></div>
    <div id="holder"></div>
	</body>
</html>
